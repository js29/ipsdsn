## Power analyses - gene editing scenario

Our eQTL data showed that differentiation produces considerable gene expression variability, which can make it difficult to discover genetic effects. They provide an opportunity to answer the question: if I made a genome edit at a putative causal variant, what is the probability that I can observe an effect on gene expression?

This probability depends on many factors, notably:
- number of replicates
- effect size
- noise (expression variability)

We will use our gene expression and QTL data to simulate a scenario where a gene edit was done to introduce the genetic effect allele. We will resample gene expression counts from major or minor allele homozygotes for QTL SNPs, and see what fraction of the time the effect would be discovered for a given number of "replicates". We can then plot these results for QTLs with different effect sizes and noise levels.

```{r Setup, warning=FALSE, message=FALSE, echo=FALSE}
library(data.table)
library(dplyr)
library(tidyr)
library(magrittr)
library(ggplot2)
library(coin)
options(stringsAsFactors=F)

exprVarianceDir <- "results/expression_variance/rpkm1/"
outputDir <- "results/power/"
```


```{r LoadData, warning=FALSE, message=FALSE, echo=FALSE}
rasqual.df = fread("results/rasqual/nopu.rasqual.500k.eigenMT.97samples.merged.leadSNPs.fdr0.1.txt", header=T) %>% tbl_df()
setnames(rasqual.df,"gene","gene_id")

fastqtl.df = fread("results/fastqtl/permutations.10k.allgenes.cis500k.PCs.20.fdr0.1.txt", header=T) %>% tbl_df()
setnames(fastqtl.df,"geneid","gene_id")

# This file is generated by compare.SN.GTEx.Rmd
rsd.df = fread("results/expression_variance/rpkm1/rpkm.summary.sn.txt") %>% tbl_df()

# We lose 2 genes where the RSD is undefined... because apparently they have
# zero expression in all samples? I don't know how we have a Rasqual eQTL then
# so this is strange.
rasqual.rsd.df = rasqual.df %>% dplyr::left_join(rsd.df, by="gene_id") %>%
  filter(!is.na(rsd))
rasqual.rsd.df$af[rasqual.rsd.df$af > 0.5] = 1 - rasqual.rsd.df$af[rasqual.rsd.df$af > 0.5]
rasqual.rsd.df$skew.raw = rasqual.rsd.df$effect_size / (1 - rasqual.rsd.df$effect_size)
rasqual.rsd.df$skew = rasqual.rsd.df$skew.raw
rasqual.rsd.df$skew[rasqual.rsd.df$skew < 1] = (1 / rasqual.rsd.df$skew[rasqual.rsd.df$skew < 1])

fastqtl.rsd.df = fastqtl.df %>% dplyr::inner_join(rsd.df, by="gene_id")
```

Let's just see the fraction of eQTLs across bins of gene expression.

```{r QTLsByExpression, warning=FALSE, message=FALSE, echo=FALSE}
rasqual.rsd.df$is.rasqual.eqtl = TRUE
fastqtl.rsd.df$is.fastqtl.eqtl = TRUE

rsd.df = rsd.df %>%
  dplyr::left_join(rasqual.rsd.df %>% dplyr::select(gene_id, af, skew, is.rasqual.eqtl, FDR), by="gene_id") %>%
  mutate(is.rasqual.eqtl = ifelse(is.na(is.rasqual.eqtl), FALSE, TRUE)) %>%
  dplyr::rename(rasqual.FDR = FDR) %>%
  dplyr::left_join(fastqtl.rsd.df %>% dplyr::select(gene_id, is.fastqtl.eqtl, FDR), by="gene_id") %>%
  mutate(is.fastqtl.eqtl = ifelse(is.na(is.fastqtl.eqtl), FALSE, TRUE)) %>%
  dplyr::rename(fastqtl.FDR = FDR)
  
rsd.df %<>% mutate(rpkm_bin = ifelse(avgrpkm < 1, "rpkm < 1",
                                     ifelse(1 <= avgrpkm & avgrpkm <= 10,
                                            "rpkm 1 - 10", "rpkm > 10")))
rsd.df$rpkm_bin = factor(rsd.df$rpkm_bin, levels=c("rpkm < 1", "rpkm 1 - 10", "rpkm > 10"))
rsd.df %<>% mutate(rpkm_bin = ifelse(avgrpkm < 0.1, "rpkm < 0.1",
                                     ifelse(0.1 <= avgrpkm & avgrpkm < 1, "rpkm 0.1 - 1",
                                     ifelse(1 <= avgrpkm & avgrpkm <= 10,
                                            "rpkm 1 - 10", "rpkm > 10"))))
rsd.df$rpkm_bin = factor(rsd.df$rpkm_bin, levels=c("rpkm < 0.1", "rpkm 0.1 - 1", "rpkm 1 - 10", "rpkm > 10"))
table(rsd.df$rpkm_bin)

rsd.dt = data.table(rsd.df)
rsd.expr.probs.df = rsd.dt[, .(rasqual=sum(is.rasqual.eqtl),
                               fastqtl=sum(is.fastqtl.eqtl),
                               gene.sum=length(is.rasqual.eqtl)), by="rpkm_bin"]
rsd.expr.gather = rsd.expr.probs.df %>% tidyr::gather(method, count, c(rasqual, fastqtl))
rsd.expr.gather$fraction = rsd.expr.gather$count / rsd.expr.gather$gene.sum

# Just plot the count or fraction of eQTLs in each expression bin.
ggplot(rsd.expr.gather, aes(x=rpkm_bin, y=count, fill=method)) + geom_bar(stat="identity", position="dodge")
ggplot(rsd.expr.gather, aes(x=rpkm_bin, y=fraction, fill=method)) + geom_bar(stat="identity", position="dodge")
```

I'm not sure this is interesting, since it doesn't tell us about the power in each expression bin. (Genes with different expression levels may be more or less likely to have true QTLs, and also genetic regulation of gene expression may be different for non-expressed genes.)

Let's see how many QTLs we have called either by Rasqual only, FastQTL only, or both - at different thresholds.
```{r QTL.numbers, warning=FALSE, message=FALSE}
sum(rsd.df$rasqual.FDR < 0.1, na.rm=T)
sum(rsd.df$fastqtl.FDR < 0.1, na.rm=T)
sum(rsd.df$rasqual.FDR < 0.1 & rsd.df$fastqtl.FDR < 0.1, na.rm=T)
sum(rsd.df$rasqual.FDR < 0.05 & rsd.df$fastqtl.FDR < 0.05, na.rm=T)
sum(rsd.df$rasqual.FDR < 0.01 & rsd.df$fastqtl.FDR < 0.01, na.rm=T)
```

What is the distribution of allelic fold changes for QTLs in different significance categories (for QTLs called by either or both Rasqual and FastQTL)?

```{r Select.genes, warning=FALSE, message=FALSE, echo=FALSE}
rsd.egenes = rsd.df %>% filter(rasqual.FDR < 0.1 | fastqtl.FDR < 0.1)
rsd.egenes$fdr.category = "both >= 0.01"
rsd.egenes$fdr.category[rsd.egenes$rasqual.FDR < 0.01] = "Rasqual < 0.01"
rsd.egenes$fdr.category[rsd.egenes$fastqtl.FDR < 0.01] = "FastQTL < 0.01"
rsd.egenes$fdr.category[rsd.egenes$rasqual.FDR < 0.01 & rsd.egenes$fastqtl.FDR < 0.01] = "both < 0.01"
ggplot(rsd.egenes[rsd.egenes$skew < 10,], aes(x=skew, fill=fdr.category)) + geom_density(alpha=0.5) +
  ggtitle("Allelic fold change for Rasqual/FastQTL FDR categories")
table(rsd.egenes$fdr.category)

rsd.intersect = rsd.df %>% filter(rasqual.FDR < 0.1, fastqtl.FDR < 0.1)
rsd.intersect$fdr.category = "one >= 0.01"
rsd.intersect %<>% mutate(fdr.category = ifelse(rasqual.FDR < 0.01 & fastqtl.FDR < 0.01, "both < 0.01", fdr.category))

ggplot(rsd.intersect[rsd.intersect$skew < 10,], aes(x=skew, fill=fdr.category)) + geom_density(alpha=0.7) +
  ggtitle("Allelic fold change for QTLs discovered by BOTH Rasqual/FastQTL (based on FDR)")
```

Clearly, QTLs with strong effect sizes (high allelic fold change) tend to be discovered with higher signficance (lower FDR). Our choice of "positive" eQTLs will thus somewhat influence the distribution of allelic fold changes. We should choose a QTL set that reflects the distribution of fold changes we want to report on.
I think it makes sense just to use Rasqual QTLs found at FDR < 0.01, regardless of whether they were discovered by FastQTL.

```{r Get.genotypes, warning=FALSE, message=FALSE, echo=FALSE}
# The genotypes matrix stores the number of copies of the REF allele per sample.
# So a value of 0 is a homozygotes ALT genotype, and 2 is homozygous REF.
genotypes.rds = "results/power/imputed.97_samples.leadSNPs.rds"
if (file.exists(genotypes.rds)) {
  vcf_file = readRDS("results/power/imputed.97_samples.leadSNPs.rds")
} else {
  library(SNPRelate)
  library(GWASTools)
  gdsToMatrix <- function(gds_file){
    
    #Extract genotypes
    gds <- GWASTools::GdsGenotypeReader(gds_file)
    genotypes = GWASTools::getGenotype(gds)
    sample_ids = GWASTools::getVariable(gds, "sample.id")
    snp_rs_ids = GWASTools::getVariable(gds, "snp.rs.id")
    snp_ids = GWASTools::getVariable(gds, "snp.id")
    
    #Invent id for snps that do not have an rs id
    new_snp_ids = paste("snp",snp_ids[snp_rs_ids == ""], sep = "")
    snp_rs_ids[snp_rs_ids == ""] = new_snp_ids
    colnames(genotypes) = sample_ids
    rownames(genotypes) = snp_rs_ids
    
    #Extract SNP coordinates
    snpspos = dplyr::data_frame(snpid = snp_rs_ids, 
               chr = GWASTools::getVariable(gds, "snp.chromosome"), 
               pos = GWASTools::getVariable(gds, "snp.position"))
    GWASTools::close(gds)
    return(list(snpspos = snpspos, genotypes = genotypes))
  }
  
  SNPRelate::snpgdsVCF2GDS("results/power/imputed.97_samples.leadSNPs.vcf", 
                           "results/power/imputed.97_samples.leadSNPs.gds",
                           method = "copy.num.of.ref")
  vcf_file = gdsToMatrix("results/power/imputed.97_samples.leadSNPs.gds")
  saveRDS(vcf_file, "results/power/imputed.97_samples.leadSNPs.rds")
}
```

```{r Get.egenes, warning=FALSE, message=FALSE, echo=FALSE}
# Get metadata for the genes that were tested for QTLs
expr_data = readRDS("../data/combined_expression_data.v5.rds")
gene_meta = expr_data$gene_metadata

sn.meta.all = read.delim("../data/metadata.all.txt")
sn.meta.all$Sample = tolower(sn.meta.all$Sample)
sn.meta.all$Protocol[grep("P2V2", sn.meta.all$Protocol)] <- "P2"
rownames(sn.meta.all) <- sn.meta.all$Sample

sn.meta = sn.meta.all %>% filter(! Sample %in% c("posc_1", "iakz_1", "koun_2", "yuze_1_1", "yuze_1_2"))

# Now remove extraction replicates, as these aren't interesting for us here
sn.meta = sn.meta %>% filter(Extraction.Replicate == "A")
rownames(sn.meta) <- sn.meta$Sample
# Fix a couple of HIPSCI genotype names (just feeder vs. feeder free genotype issues)
sn.meta$HipsciID[sn.meta$HipsciID == "HPSI0613i-xavk_3"] = "HPSI0613i-xavk_33"
sn.meta$HipsciID[sn.meta$HipsciID == "HPSI0513i-oarz_22"] = "HPSI0513i-oarz_2"

# Focus on P2 samples.
sn.meta.P2 = sn.meta %>% filter(Protocol == "P2")

# Remove samples that we don't have genotypes for.
sn.meta.P2$HipsciID[!sn.meta.P2$HipsciID %in% colnames(vcf_file$genotypes)]
sn.meta.sim = sn.meta.P2 %>% filter(HipsciID %in% colnames(vcf_file$genotypes))

colnames(expr_data$exprs_counts) = tolower(colnames(expr_data$exprs_counts))
sn.counts = expr_data$exprs_counts[, sn.meta.sim$Sample]

# Define "gold standard" set of eGenes - Rasqual eGenes with FDR < 0.01
rsd.gs = rasqual.rsd.df %>% filter(FDR < 0.01)
# Remove genes where too many samples have zero counts, otherwise we get
# errors later on when resampling counts
rsd.gs$zero.counts = rowSums(sn.counts[rsd.gs$gene_id,] == 0)
rsd.gs %<>% filter(zero.counts < 10)

gs.snps = rsd.gs$snpid

# genotypes.gs will have genotypes for all samples, including some identical
# genotype columns for those samples differentiated more than once. This makes
# it easy to resample from the relevant genotypes later on.
gs.genotypes = vcf_file$genotypes[rsd.gs$snpid, sn.meta.sim$HipsciID]
#gs.genotypes = vcf_file$genotypes[rsd.gs$snpid, unique(sn.meta.sim$HipsciID)]

# A handful (3) of SNPs don't have genotype data for all samples. Not sure why.
badSnps = rownames(gs.genotypes[is.na(rowSums(gs.genotypes)),])
gs.snps = gs.snps[!gs.snps %in% badSnps]
gs.genes = rsd.gs[!rsd.gs$snpid %in% badSnps,]
gs.genotypes = gs.genotypes[gs.snps,]

# Write the table of our gold standard set of genes
fname = paste0(outputDir, "goldstandard.geneset.txt")
write.table(gs.genes, fname, quote=F, row.names=F, col.names=T, sep="\t")
```

For the simulation, we will sample gene expression from cell lines that are homozygous for either the ref or alt alleles at a QTL SNP. 
Let's check for how many SNPs we have at least N of both major and minor allele homozygotes.

```{r Check.egene.genotypes, warning=FALSE, message=FALSE, echo=FALSE}
numGenesUsable = sapply(3:30, FUN=function(n) sum(apply(gs.genotypes, 1, function(x) {sum(x == 0) >= n & sum(x == 2) >= n})))
numGenes.df = data.frame(minAC = 3:30, numGenesUsable = numGenesUsable)
ggplot(numGenes.df, aes(x=minAC, y=numGenesUsable)) + geom_point() + theme_bw() +
  xlab("Genes with at least X major & minor allele homozygotes") + ylab("Number of genes")
numGenes.df
```

To be able to detect an effect when comparing samples with homozygous ref vs. homozygous alt genotypes, the direction of effect would have to be consistent with that reported by Rasqual. Let's check.

```{r Check.egene.genotypes.2, warning=FALSE, message=FALSE, echo=FALSE}
# Subset to genes where we have at least minHomozygotes samples
# in each homozygous genotype category (ref, alt)
minHomozygotes = 10
usableSnps = apply(gs.genotypes, 1, function(x) {sum(x == 0) >= minHomozygotes & sum(x == 2) >= minHomozygotes})
sum(usableSnps == T)

sim.snps = gs.snps[usableSnps]
sim.genes = gs.genes[usableSnps,]
nGenes = length(sim.genes$gene_id)

sim.counts = sn.counts[sim.genes$gene_id,]
# Get counts per million for genes of interest
sim.cpm = t(1e6 * t(sn.counts[sim.genes$gene_id,]) / colSums(sn.counts))
sim.genotypes = gs.genotypes[sim.snps,]

sn.cpm = t(1e6 * t(sn.counts) / colSums(sn.counts))

# We have the allelic skew from rasqual, but let's also get the ratio of
# mean counts (normalized) between homozygous and het genotypes. This should
# be consistent with the Rasqual allelic skew.
getHomozygoteAlleleRatio = function(genotypes, counts, i) {
  mean(counts[i, genotypes[i,] == 0]) / mean(counts[i, genotypes[i,] == 2])
}
sim.genes$homCountRatio = unlist(lapply(1:nGenes, FUN=function(geneIndex) getHomozygoteAlleleRatio(sim.genotypes, sim.cpm, geneIndex)))
sim.genes$homCountRatio.signed = sim.genes$homCountRatio
sim.genes$homCountRatio.signed[sim.genes$homCountRatio < 1] = -1 / sim.genes$homCountRatio[sim.genes$homCountRatio < 1]
sim.genes$skew.signed = sim.genes$skew.raw
sim.genes$skew.signed[sim.genes$skew.raw < 1] = -1 / sim.genes$skew.raw[sim.genes$skew.raw < 1]
sim.genes$homCountRatio.pos = sim.genes$homCountRatio
sim.genes$homCountRatio.pos[sim.genes$homCountRatio.pos < 1] = 1 / sim.genes$homCountRatio[sim.genes$homCountRatio.pos < 1]

ggplot(sim.genes, aes(x=skew.signed, y=homCountRatio.signed)) + geom_point(alpha=0.4) +
  xlim(c(-5,5)) + ylim(-10,10) + 
  xlab("Skew from Rasqual: pi / (1-pi)") +
  ylab("Expression ratio: hom alt / hom ref") +
  ggtitle("Effect sizes from Rasqual vs. homozygote expression ratio") +
  theme_grey(15)
```

So the expression ratio is almost always consistent with with Rasqual's effect size estimate and direction. But there are a handful of genes where the effect size is quite different or in the opposite direction. For our "positive eGene" set we'll drop these genes. We also drop genes where the CV is > 2, because there are only a handful of genes and this makes plotting easier.

Let's also compare Rasqual effect size with FastQTL.

```{r Check.egene.genotypes.3, warning=FALSE, message=FALSE, echo=FALSE}
# Do the same comparison with FastQTL effect sizes
sim.genes.fastqtl = sim.genes %>% left_join(fastqtl.df %>% select(gene_id, slope)) %>% mutate(slope = ifelse(is.na(slope), 0, slope))

ggplot(sim.genes.fastqtl, aes(x=skew.signed, y=slope)) + geom_point(alpha=0.5) +
  xlim(c(-5, 5)) + ylim(c(-2,2))

#ggplot(sim.genes.fastqtl, aes(x=homCountRatio.signed, y=slope, col=factor(sign(skew.signed)))) + geom_point(alpha=0.5) +
#  xlim(c(-5, 5)) + ylim(c(-2,2))
```

There seem to be more genes which are off the diagonal - or at least where the effect is significantly different. There are also a number of genes which are not FastQTL QTLs, and so I don't have an effect size estimate (the zeros along the X axis).

```{r Check.egene.genotypes.4, warning=FALSE, message=FALSE, echo=FALSE, eval=FALSE}
# Here we manually check some of the cases where the ratio of hom alt / hom ref 
# mean expression is discordant with Rasqual's effect size skew. We should keep
# in mind that here we are not using any PCs - whereas in the QTL calling, PCs
# are used as covariates, which will change the association.
genes.reverseSigns = sim.genes %>% filter(skew.signed > 1 & homCountRatio.signed < 1 | skew.signed < 1 & homCountRatio.signed > 1)
reverseIndices = which(sim.genes$skew.signed > 1 & sim.genes$homCountRatio.signed < -1 | sim.genes$skew.signed < -1 & sim.genes$homCountRatio.signed > 1)

plotCounts = function(genotypes, cpm, genes, geneIndex) {
  df = data.frame(gt=factor(genotypes[geneIndex,]), cpm=cpm[geneIndex,])
  skewText = sprintf("Rasqual pi = %.3f", genes[geneIndex,]$effect_size)
  alleleRatioText = sprintf("homalt/homref cpm ratio = %.3f", genes[geneIndex,]$homCountRatio.signed)
  ggplot(df, aes(x=factor(gt), y=cpm)) +
    geom_boxplot(outlier.shape = NA) + geom_jitter(width=0.2) + theme_bw() +
    annotate("text", x=levels(df$gt)[2], y=max(cpm[geneIndex,]), label=skewText, size=5) +
    annotate("text", x=levels(df$gt)[3], y=max(cpm[geneIndex,]), label=alleleRatioText, size=5)
}
plotCounts(sim.genotypes, sim.cpm, sim.genes, reverseIndices[1])
# plotCounts(sim.genotypes, sim.cpm, sim.genes, reverseIndices[2])
# plotCounts(sim.genotypes, sim.cpm, sim.genes, reverseIndices[3])
# plotCounts(sim.genotypes, sim.cpm, sim.genes, reverseIndices[4])
# plotCounts(sim.genotypes, sim.cpm, sim.genes, reverseIndices[5])
# plotCounts(sim.genotypes, sim.cpm, sim.genes, reverseIndices[6])

genes.highHomCountRatio = sim.genes %>% filter(homCountRatio.signed < -2 | homCountRatio.signed > 2)
highHomCountRatioIndices = which(sim.genes$homCountRatio.signed < -2 | sim.genes$homCountRatio.signed > 2)
plotCounts(sim.genotypes, sim.cpm, sim.genes, highHomCountRatioIndices[1])
# plotCounts(sim.genotypes, sim.cpm, sim.genes, highHomCountRatioIndices[2])
# plotCounts(sim.genotypes, sim.cpm, sim.genes, highHomCountRatioIndices[3])
# plotCounts(sim.genotypes, sim.cpm, sim.genes, highHomCountRatioIndices[4])
```


```{r Subset.to.consistent.egenes, warning=FALSE, message=FALSE, echo=FALSE}
sum(sim.genes$rsd > 2)
sim.genes = sim.genes[sign(sim.genes$homCountRatio.signed) == sign(sim.genes$skew.signed) & sim.genes$rsd <= 2,]
sim.snps = sim.genes$snpid
nGenes = length(sim.genes$gene_id)

sim.counts = sn.counts[sim.genes$gene_id,]
# Get counts per million for genes of interest
sim.cpm = t(1e6 * t(sn.counts[sim.genes$gene_id,]) / colSums(sn.counts))
sim.genotypes = gs.genotypes[sim.snps,]

# Save the set of genes we're using in our expression resampling
fname = paste0(outputDir, "expression.resampling.geneset.txt")
write.table(sim.genes, fname, quote=F, row.names=F, col.names=T, sep="\t")
```

Let's now do the resampling.

```{r Expression.resampling, warning=FALSE, message=FALSE, echo=FALSE}
# Resamples expression once for a given gene and number of replicates,
# does a statistical test and returns the result from the stat function.
resampleExpressionForGene = function(genotypes, counts, nReps, i, permute=F, test="wilcoxon") {
  # i is gene index
  #df = data.frame(genotype = c(rep(0, nReps), rep(2, nReps)),
  #                count = c(sample(counts[i, genotypes[i,] == 0], nReps),
  #                          sample(counts[i, genotypes[i,] == 2], nReps)))
  #res = t.test(df$count, df$genotype, var.equal = T)

  #df = data.frame(gt0 = sample(counts[i, genotypes[i,] == 0], nReps),
  #                gt2 = sample(counts[i, genotypes[i,] == 2], nReps))
  #res = t.test(df$gt0, df$gt2, var.equal = T)
  tries = 0
  res = NULL
  while (tries < 10 & is.null(res)) {
    tries = tries + 1
    tryCatch(
        {
          if (permute) {
            homGenotypes = (genotypes[i,] == 0 | genotypes[i,] == 2)
            gt0 = sample(counts[i, homGenotypes], nReps, replace = T)
            gt2 = sample(counts[i, homGenotypes], nReps, replace = T)
          } else {
            gt0 = sample(counts[i, genotypes[i,] == 0], nReps, replace = T)
            gt2 = sample(counts[i, genotypes[i,] == 2], nReps, replace = T)
          }
          if (test == "wilcoxon") {
            df = data.frame(expr = c(gt0, gt2), gt = factor(rep(c(0,2), c(length(gt0), length(gt2)))))
            res = wilcox_test(expr ~ gt, data=df, distribution = "exact", alternative="two.sided")
            #res = wilcox_test(expr ~ gt, data=df, distribution = "asymptotic", alternative="two.sided")
            #res = wilcox_test(expr ~ gt, data=df, distribution = "approximate", alternative="two.sided")
          } else {
            res = t.test(gt0, gt2, var.equal = T)
          }
        },
        error=function(cond) {
            message(paste0(cond, "\n"))
        }
    )
  }
  if (tries >= 10) {
    message(paste("Failed to do resampling for gene", i))
    exit(1)
  }
  res
}

# Does a set of nResamples tests for a given gene and number of replicates.
doGeneResamples = function(geneIndex, nResamples, nReps, test="wilcoxon", permute=F) {
  lapply(1:nResamples, FUN=function(x) resampleExpressionForGene(sim.genotypes, sim.cpm, nReps=nReps, geneIndex, test=test, permute=permute))
}

compareGeneEffectDirections = function(geneResults, geneIndex) {
  expectedSkew = sim.genes[geneIndex, ]$skew.raw
  actualSkews = lapply(geneResults, FUN=function(obj) obj$estimate[1] / obj$estimate[2])
  samedirs = (expectedSkew > 1 & actualSkews > 1) | (expectedSkew < 1 & actualSkews < 1)
  samedirs
}
countFalseDirectionAssociations.ttest = function(geneResults, sim.genes, geneIndex) {
  expectedSkew = sim.genes[geneIndex, ]$skew.raw
  actualSkews = sapply(geneResults, FUN=function(obj) obj$estimate[1] / obj$estimate[2])
  actualPvals = sapply(geneResults, FUN=function(obj) obj$p.value)
  samedirs = (expectedSkew > 1 & actualSkews > 1) | (expectedSkew < 1 & actualSkews < 1)
  actualPvals < pThreshold & !samedirs
}
countFalseDirectionAssociations.wilcox = function(geneResults, sim.genes, geneIndex) {
  expectedSkew = sim.genes[geneIndex, ]$skew.raw
  actualSkewDir = sapply(geneResults, FUN=function(obj) statistic(obj))
  actualPvals = sapply(geneResults, FUN=function(obj) pvalue(obj))
  samedirs = (expectedSkew > 1 & actualSkewDir > 0) | (expectedSkew < 1 & actualSkewDir < 0)
  actualPvals < pThreshold & !samedirs
}

getResamplingResults.ttest = function(sim.genes, nReplicates, nResamples, pThreshold, permute=F) {
  nGenes = length(sim.genes$gene_id)
  geneResList = lapply(1:nGenes, FUN=function(geneIndex) doGeneResamples(geneIndex,
                                                                         nResamples=nResamples,
                                                                         nReps=nReplicates,
                                                                         test="t-test",
                                                                         permute=permute))
  genePvals = t(matrix(unlist(lapply(geneResList, FUN=function(l1) {lapply(l1, FUN=function(obj) obj$p.value)})),
                     ncol=nGenes))
  falseAssocs = t(matrix(unlist(lapply(1:nGenes, FUN=function(geneIndex) countFalseDirectionAssociations.ttest(geneResList[[geneIndex]], sim.genes, geneIndex))),
                       ncol=nGenes))
  
  significantRate = rowSums(genePvals < pThreshold) / nResamples
  signErrorRate = rowSums(falseAssocs) / nResamples
  list(significantRate = significantRate, signErrorRate = signErrorRate)
}

getResamplingResults.wilcox = function(sim.genes, nReplicates, nResamples, pThreshold, permute=F) {
  nGenes = length(sim.genes$gene_id)
  geneResList = lapply(1:nGenes, FUN=function(geneIndex) doGeneResamples(geneIndex,
                                                                         nResamples=nResamples,
                                                                         nReps=nReplicates,
                                                                         test="wilcoxon",
                                                                         permute=permute))
  genePvals = t(matrix(unlist(lapply(geneResList, FUN=function(l1) {lapply(l1, FUN=function(obj) pvalue(obj))})),
                     ncol=nGenes))
  falseAssocs = t(matrix(unlist(lapply(1:nGenes, FUN=function(geneIndex) countFalseDirectionAssociations.wilcox(geneResList[[geneIndex]], sim.genes, geneIndex))),
                       ncol=nGenes))
  
  significantRate = rowSums(genePvals < pThreshold) / nResamples
  signErrorRate = rowSums(falseAssocs) / nResamples
  list(significantRate = significantRate, signErrorRate = signErrorRate)
}

hist(sim.genes$homCountRatio[sim.genes$homCountRatio<2], breaks=100)
#hist(log(sim.genes$homCountRatio), breaks=100)
# How many genes have effect sizes that are probably too small to detect?
sum(0.95 < sim.genes$homCountRatio & sim.genes$homCountRatio < 1.05)
sum(0.90 < sim.genes$homCountRatio & sim.genes$homCountRatio < 1.1)
length(sim.genes$homCountRatio)

factorize = function(values, cuts) {
  cutnames = c(sprintf("< %g", cuts[1]))
  if (length(cuts > 1)) {
    for (i in 2:length(cuts)) {
      cutnames = c(cutnames, sprintf("%g-%g", cuts[i-1], cuts[i]))
    }
  }
  cutnames = c(cutnames, sprintf(">= %g", cuts[length(cuts)]))
  factorvals = rep(cutnames[1], length(values))
  for (i in 1:(length(cuts))) {
    factorvals[values > cuts[i]] = cutnames[i+1]
  }
  factor(factorvals, levels=cutnames)
}

getResultsDF = function(res, nReplicates) {
  resCols = c("gene_id", "skew", "skew.signed", "homCountRatio", "homCountRatio.signed", "homCountRatio.pos", "rsd", "avgrpkm")
  sim.genes.res = sim.genes[, resCols]
  sim.genes.res$nReplicates = nReplicates
  sim.genes.res$TPR = res$significantRate - res$signErrorRate
  sim.genes.res$signErrorRate = res$signErrorRate
  sim.genes.res$rsd.category = factorize(sim.genes.res$rsd, cuts=c(0.3, 0.5, 0.75))
  sim.genes.res$homCountRatio.pos.category = factorize(sim.genes.res$homCountRatio.pos, cuts=c(1.1, 1.25, 1.5, 2))
  sim.genes.res
}

nResamples = 100
pThreshold = 0.05

results.all.fname = paste0(outputDir, "resampling.results.all.rds")
if (file.exists(results.all.fname)) {
  results.all = readRDS(results.all.fname)
} else {
  results = list()
  results$resamples.3 = getResultsDF( getResamplingResults.ttest(sim.genes, nReplicates=3, nResamples, pThreshold), 3)
  results$resamples.6 = getResultsDF( getResamplingResults.ttest(sim.genes, nReplicates=6, nResamples, pThreshold), 6)
  results$resamples.10 = getResultsDF( getResamplingResults.ttest(sim.genes, nReplicates=10, nResamples, pThreshold), 10)
  results$resamples.20 = getResultsDF( getResamplingResults.ttest(sim.genes, nReplicates=20, nResamples, pThreshold), 20)
  results$resamples.40 = getResultsDF( getResamplingResults.ttest(sim.genes, nReplicates=40, nResamples, pThreshold), 40)
  results.all = rbind(results$resamples.3,
                      results$resamples.6,
                      results$resamples.10,
                      results$resamples.20,
                      results$resamples.40)
  saveRDS(results.all, file=)
}

results.all.w.fname = paste0(outputDir, "resampling.results.all.w.rds")
if (file.exists(results.all.w.fname)) {
  results.all.w = readRDS(results.all.w.fname)
} else {
  results_w = list()
  results_w$resamples.4 = getResultsDF( getResamplingResults.wilcox(sim.genes, nReplicates=4, nResamples, pThreshold), 4)
  results_w$resamples.6 = getResultsDF( getResamplingResults.wilcox(sim.genes, nReplicates=6, nResamples, pThreshold), 6)
  results_w$resamples.10 = getResultsDF( getResamplingResults.wilcox(sim.genes, nReplicates=10, nResamples, pThreshold), 10)
  results_w$resamples.20 = getResultsDF( getResamplingResults.wilcox(sim.genes, nReplicates=20, nResamples, pThreshold), 20)
  results_w$resamples.40 = getResultsDF( getResamplingResults.wilcox(sim.genes, nReplicates=40, nResamples, pThreshold), 40)
  results.all.w = rbind(results_w$resamples.4,
                        results_w$resamples.6,
                        results_w$resamples.10,
                        results_w$resamples.20,
                        results_w$resamples.40)
  saveRDS(results.all.w, file=paste0(outputDir, "resampling.results.all.w.rds"))
}
```

First we look at the true positive rate (TPR) versus effect size, where effect size is measured as the fold change between alleles. This is computed as the mean ratio of expression of homozygous alt/ref genotypes, with the higher expressing genotype in the numerator. We initially look at this assuming 10 replicates in each genotype category (homozygous ref, homozygous alt).

```{r Resampling.plots.1, warning=FALSE, message=FALSE, echo=FALSE}
ratioBreaks = c(1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 2.0, 5.0)
ratioLabels = c("1.0", "", "", "", "", "1.5", "2.0", "5.0")
rsdBreaks = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.5, 2.0, 5.0)
rsdLabels = c("0.1", "", "", "", "0.5", "", "", "", "", "1.0", "1.5", "2.0", "5.0")
TPRBreaks = c(0.0, 0.2, 0.4, 0.6, 0.8, 1.0)
numRepBreaks = c(3,6,10,20,40)
results.all$nReplicatesF = factor(results.all$nReplicates, levels=numRepBreaks)
numRepBreaks = c(4,6,10,20,40)
results.all.w$nReplicatesF = factor(results.all.w$nReplicates, levels=numRepBreaks)

ggplot(results.all.w[results.all.w$nReplicates == 10,], aes(x=homCountRatio.pos, y=TPR)) + geom_point()
ggplot(results.all.w[results.all.w$nReplicates == 10,], aes(x=skew, y=TPR)) + geom_point()

effectSize_TPR_plot = function(sim.genes.res, titlestr) {
  ggplot(sim.genes.res, aes(x=homCountRatio.pos, y=TPR, col=rsd.category)) +
      geom_point(alpha=0.8) + geom_smooth() +
      geom_point(aes(x=homCountRatio.pos, y=signErrorRate, col=rsd.category)) +
      geom_smooth(aes(x=homCountRatio.pos, y=signErrorRate, col=rsd.category)) +
      theme_bw(16) + #xlim(c(1,5)) + #ylim(c(-0.05, 1.05)) +
      ggtitle(titlestr) + xlab("Ratio of higher expressed allele to lower") +
      scale_color_discrete(name="CV category") +
      scale_x_log10(breaks=ratioBreaks, labels=ratioLabels, limits=c(1,5)) +
      scale_y_continuous(breaks=TPRBreaks)
}

CV_TPR_plot = function(sim.genes.res, titlestr) {
  ggplot(sim.genes.res, aes(x=rsd, y=TPR, col=homCountRatio.pos.category)) +
    geom_point(alpha=0.8) + geom_smooth() +
    scale_x_log10(breaks=rsdBreaks, labels=rsdLabels, limits=c(0.1, 2)) +
    scale_y_continuous(breaks=TPRBreaks) +
    scale_color_discrete(name="Allelic\nfold change") +
    theme_bw(16) + #xlim(c(0,2)) + #ylim(c(-0.1, 1.1)) +
    ggtitle(titlestr) + xlab("Coefficient of variation")
}


# Plot the results: effect size vs. TPR, stratified by CV
p1 = effectSize_TPR_plot(results$resamples.3, "3 replicates")
p2 = effectSize_TPR_plot(results$resamples.6, "6 replicates")
p3 = effectSize_TPR_plot(results$resamples.10, "10 replicates")
p4 = effectSize_TPR_plot(results$resamples.20, "20 replicates")
p5 = effectSize_TPR_plot(results$resamples.40, "40 replicates")
print(p3)
```

There's higher power for genes with lower CV, as expected. Next we plot TPR vs. CV, stratified by the allelic fold change.

```{r Resampling.plots.2, warning=FALSE, message=FALSE, echo=FALSE}
# Plot the results: CV vs. TPR, stratified by effect size
p6 = CV_TPR_plot(results$resamples.3, "3 replicates")
p7 = CV_TPR_plot(results$resamples.6, "6 replicates")
p8 = CV_TPR_plot(results$resamples.10, "10 replicates")
p9 = CV_TPR_plot(results$resamples.20, "20 replicates")
p10 = CV_TPR_plot(results$resamples.40, "40 replicates")
print(p8 + theme(plot.title = element_blank()) + coord_cartesian(ylim=c(0,1)))

# Export at size 6.5x5 for figure
p8 = CV_TPR_plot(results_w$resamples.10, "10 replicates")
print(p8 + theme(plot.title = element_blank()) + coord_cartesian(ylim=c(0,1)))
```

As expected, there's higher power when the effect size is larger. For small effect alleles, power to detect an effect is low even with a large number of replicates.

```{r Resampling.plots.2.a, warning=FALSE, message=FALSE, echo=FALSE, eval=FALSE}
# Look at false positive rates when the genotypes are permuted.
# This basically ended up showing that the t-test is well calibrated.
# I.e. as you should expect, you get a ~5% error rate when you use
# a significance threshold of 0.05, if the genotypes are randomized.
results$resamples.3.perm = getResultsDF( getResamplingResults(sim.genes, nReplicates=3, nResamples, pThreshold, permute=T), 3)
results$resamples.6.perm = getResultsDF( getResamplingResults(sim.genes, nReplicates=6, nResamples, pThreshold, permute=T), 6)
results$resamples.10.perm = getResultsDF( getResamplingResults(sim.genes, nReplicates=10, nResamples, pThreshold, permute=T), 10)
#results$resamples.20.perm = getResultsDF( getResamplingResults(sim.genes, nReplicates=20, nResamples, pThreshold, permute=T), 20)
#results$resamples.40.perm = getResultsDF( getResamplingResults(sim.genes, nReplicates=40, nResamples, pThreshold, permute=T), 40)

effectSize_TPR_plot(results$resamples.3.perm, "3 replicates-PERMUTED")
effectSize_TPR_plot(results$resamples.6.perm, "6 replicates-PERMUTED")
effectSize_TPR_plot(results$resamples.10.perm, "10 replicates-PERMUTED")

hist(results$resamples.3$signErrorRate)
hist(results$resamples.6$signErrorRate)
hist(results$resamples.10$signErrorRate)
```

Let's look at these effects for different numbers of replicates.

```{r Resampling.plots.3, warning=FALSE, message=FALSE, echo=FALSE}
library(gridExtra)

# Plot the results: effect size vs. TPR, stratified by nReplicates

TPR_effectsize_plots =
  ggplot(results.all.w, aes(x=homCountRatio.pos, y=TPR, col=rsd.category)) +
    geom_point(alpha=0.6) + geom_smooth() +
    theme_bw() + #xlim(c(1,5)) + #ylim(c(-0.05, 1.05)) +
    ggtitle("TPR vs. effect size, stratified by CV") +
    xlab("Ratio of higher expressed allele to lower") +
    scale_color_discrete(name="CV category") +
    scale_x_log10(breaks=ratioBreaks, labels=ratioLabels, limits=c(1,5)) +
    scale_y_continuous(breaks=TPRBreaks) +
    facet_wrap(~nReplicatesF, ncol=1)

TPR_CV_plots =
  ggplot(results.all.w, aes(x=rsd, y=TPR, col=homCountRatio.pos.category)) +
    geom_point(alpha=0.6) + geom_smooth() +
    scale_x_log10(breaks=rsdBreaks, labels=rsdLabels, limits=c(0.1, 2)) +
    scale_y_continuous(breaks=TPRBreaks) +
    scale_color_discrete(name="Allelic\nfold change") +
    theme_bw() + #xlim(c(0,2)) + #ylim(c(-0.1, 1.1)) +
    ggtitle("TPR vs. CV, stratified by effect size") +
    xlab("Coefficient of variation") +
    facet_wrap(~nReplicatesF, ncol=1)

grid.arrange(grobs=list(TPR_effectsize_plots, TPR_CV_plots), ncol=2)
```

We can also stratify by the number of replicates (across genes at all levels of noise / CV).

```{r Resampling.plots.4, warning=FALSE, message=FALSE, echo=FALSE}

# Export at size 6.5x5 for figure
ggplot(results.all.w, aes(x=homCountRatio.pos, y=TPR, col=nReplicatesF)) +
    geom_point(alpha=0.6) + geom_smooth() +
    theme_bw(16) + #xlim(c(1,5)) + #ylim(c(-0.05, 1.05)) +
    xlab("Ratio of higher expressed allele to lower") +
    scale_color_discrete(name="Replicates") +
    scale_x_log10(breaks=ratioBreaks, labels=ratioLabels, limits=c(1,5)) +
    scale_y_continuous(breaks=TPRBreaks) +
    coord_cartesian(ylim=c(0,1))
    #ggtitle("TPR vs. effect size, stratified by number of replicates") +


results$resamples.15 = getResultsDF( getResamplingResults(sim.genes, nReplicates=15, nResamples, pThreshold), 15)
results$resamples.30 = getResultsDF( getResamplingResults(sim.genes, nReplicates=30, nResamples, pThreshold), 30)
results.all.2 = rbind(results$resamples.3,
                    results$resamples.6,
                    results$resamples.10,
                    results$resamples.15,
                    results$resamples.20,
                    results$resamples.30,
                    results$resamples.40)
numRepBreaks2 = c(3,6,10,15,20,30,40)
results.all.2$nReplicatesF = factor(results.all.2$nReplicates, levels=numRepBreaks2)

ggplot(results.all, aes(x=nReplicates, y=TPR, col=homCountRatio.pos.category)) +
    geom_jitter(alpha=0.5, width=1.5) + geom_smooth() +
    theme_bw(16) + #xlim(c(1,5)) + #ylim(c(-0.05, 1.05)) +
    ggtitle("TPR vs. number of replicates, stratified by effect size") +
    xlab("Number of replicates") +
    scale_color_discrete(name="Allelic\nfold change") +
    scale_y_continuous(breaks=TPRBreaks) +
    scale_x_continuous(breaks=numRepBreaks)

# Export at size 6.5x5 for figure
ggplot(results.all.2, aes(x=jitter(nReplicates, amount = (nReplicates/25)), y=TPR, col=homCountRatio.pos.category)) +
    geom_point(alpha=0.5) + geom_smooth(span=1.5) +
    theme_bw(16) + #xlim(c(1,5)) + #ylim(c(-0.05, 1.05)) +
    xlab("Number of replicates") +
    scale_color_discrete(name="Allelic\nfold change") +
    scale_y_continuous(breaks=TPRBreaks) +
    scale_x_log10(breaks=numRepBreaks2)
    #ggtitle("TPR vs. number of replicates, stratified by effect size") +

ggplot(results.all.2, aes(x=jitter(nReplicates), y=TPR, col=homCountRatio.pos.category)) +
    geom_point(alpha=0.5) + geom_smooth(span=1.8) +
    theme_bw(16) + #xlim(c(1,5)) + #ylim(c(-0.05, 1.05)) +
    xlab("Number of replicates") +
    scale_color_discrete(name="Allelic\nfold change") +
    scale_y_continuous(breaks=TPRBreaks) +
    scale_x_continuous(breaks=numRepBreaks2)
    #ggtitle("TPR vs. number of replicates, stratified by effect size") +
```

Let's see how power changes depending on the amount to which a gene is upregulated from iPSCs to IPSDSNs.

```{r Resampling.plots.5, warning=FALSE, message=FALSE, echo=FALSE}
deseq.df = read.delim("results/ipsc_sn/deseq.iPSC.vs.SN.ff.results.txt")

# Subset to genes which are not significantly downregulated in IPSDSNs relative to IPSCs
deseq.notdown.fc.df = deseq.df %>% select(gene_id, log2FoldChange)
results.all.de = results.all %>% inner_join(deseq.notdown.fc.df, by="gene_id")

ggplot(results.all.de, aes(x=log2FoldChange, y=TPR, col=nReplicatesF)) +
    geom_point(alpha=0.6) + geom_smooth() +
    theme_bw(16) +
    xlab("log2 fold change between IPSDSN and iPSC") +
    scale_color_discrete(name="Replicates") +
    scale_y_continuous(breaks=TPRBreaks) +
    coord_cartesian(xlim=c(-5, 10), ylim=c(0, 1))
    #ggtitle("TPR vs. fold change between IPSDSNs and iPSCs") +

results.all.de$expressionBin = factorize(results.all.de$avgrpkm, cuts=c(3,6,15))
ggplot(results.all.de, aes(x=log2FoldChange, y=TPR, col=expressionBin)) +
    geom_point(alpha=0.6) + geom_smooth() +
    theme_bw(16) +
    ggtitle("TPR vs. fold change between IPSDSNs and iPSCs") +
    xlab("log2 fold change between IPSDSN and iPSC") +
    scale_color_discrete(name="Expression\n(FPKM)") +
    scale_y_continuous(breaks=TPRBreaks) +
    coord_cartesian(xlim=c(-5, 10), ylim=c(0, 1))

# Correlation of fold change and CV
ggplot(results.all.de, aes(x=log2FoldChange, y=rsd)) +
    geom_point() + geom_smooth() +
    theme_bw(16) +
    ggtitle("Gene CV vs. fold change between IPSDSNs and iPSCs") +
    xlab("log2 fold change between IPSDSN and iPSC") + ylab("CV") +
    scale_color_discrete(name="Replicates") +
    coord_cartesian(xlim=c(-5, 10))

ggplot(results.all.de, aes(x=log2FoldChange, y=rsd, col=expressionBin)) +
    geom_point() + geom_smooth() +
    theme_bw(16) +
    ggtitle("Gene CV vs. fold change between IPSDSNs and iPSCs") +
    xlab("log2 fold change between IPSDSN and iPSC") + ylab("CV") +
    scale_color_discrete(name="Expression\n(FPKM)") +
    coord_cartesian(xlim=c(-5, 10))
```

Let's see if we can show how TPR varies in specific gene categories.

```{r Resampling.plots.6, warning=FALSE, message=FALSE, echo=FALSE}
# Load gene IDs in different GO categories
terms = c("cell_cycle", "apoptotic process", "vesicle membrane",
             "immune response",
             "cell_differentiation", "CNS_development", "nervous_system_dev",
             "extracell_matrix_org", "axonogenesis", "neurogenesis", 
             "sensory_organ_dev", "synaptic_signaling")
termNames = gsub("_", " ", terms)

terms = c("cell_cycle", "vesicle membrane", "nervous_system_dev", "sensory_organ_dev", "extracell_matrix_org")
terms = c("cell_cycle", "vesicle membrane", "nervous_system_dev", "immune response", "sensory_organ_dev", "extracell_matrix_org")
termNames = gsub("_", " ", terms)

plot.df = data.frame()
for (term in terms) {
  print(term)
  term.df = read.delim(paste0("results/expression_variance/rpkm1/go/go.", term, ".genes.txt")) %>% dplyr::select(gene_id = Gene.ID)
  results.term = results.all %>% inner_join(term.df, by="gene_id")
  results.term$term = gsub("_", " ", term)
  print(paste0("Number of genes: ", nrow(results.term) / length(unique(results.term$nReplicates))))
  print(sprintf("median CV: %.3g   median fold change: %.3g", median(results.term$rsd), median(results.term$skew)))
  print(median(results.term$skew)^2 / median(results.term$rsd))
  plot.df = rbind(plot.df, results.term)
}
plot.df$term = factor(plot.df$term, levels=termNames)

ggplot(plot.df, aes(x=term, y=TPR)) +
  geom_boxplot(aes(fill=nReplicatesF), alpha=0.8, outlier.shape = NA) +
  geom_jitter(position = position_dodge(width = 0.75), size=0.8, alpha=0.6, aes(group=nReplicatesF)) +
  theme_bw(16) +
  ggtitle("") +
  xlab("GO term") +
  scale_y_continuous(breaks=TPRBreaks) +
  theme(axis.text.x=element_text(angle=30))


ggplot(plot.df, aes(x=nReplicatesF, y=TPR)) +
  geom_boxplot(aes(fill=term), alpha=0.8, outlier.shape = NA) +
  geom_jitter(position = position_dodge(width = 0.75), size=0.8, alpha=0.6, aes(group=term)) +
  theme_bw(16) +
  ggtitle("") +
  xlab("GO term") +
  scale_y_continuous(breaks=TPRBreaks)


ggplot(plot.df, aes(x=nReplicatesF, y=TPR)) +
  geom_boxplot(aes(fill=term), alpha=0.8, outlier.shape = NA) +
  geom_jitter(position = position_jitter(width = 0.25), size=0.8, alpha=0.5, aes(group=nReplicatesF)) +
  theme_bw(16) +
  xlab("Number of replicates") +
  scale_y_continuous(breaks=TPRBreaks) +
  facet_wrap(~term, nrow=2) +
  theme(strip.background = element_rect(fill="white", linetype="blank"), strip.text = element_text()) +
  theme(panel.margin.y=unit(0.3, "cm")) +
  theme(legend.position="none")
```

